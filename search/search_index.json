{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Enhance your game with scalable, dynamic code. Getting started"},{"location":"#introduction","title":"Introduction","text":"<p>Celesta is a library for Entity Component System (ECS) that adopts an event-driven approach to simplify development and reduce the complexity associated with traditional ECS loops.</p>"},{"location":"#components","title":"Components","text":"<p>Components in Celesta are defined simply and intuitively.   They are used to store data related to an entity. Here is an example of how to define components for health and regeneration:</p> <pre><code>local Health = Celesta.Component {\n    max = 100,\n    current = 100\n}\n\nlocal Regeneration = Celesta.Component {\n    duration = 5,\n    amount = 10\n}\n</code></pre>"},{"location":"#query","title":"Query","text":"<p>The Query object is used to combine components that need to be considered in a system. It defines which components are required for a trait to function. Here is an example of defining a query between Health and Regeneration:</p> <pre><code>local Query = Celesta.Query(Health, Regeneration)\n</code></pre>"},{"location":"#traits","title":"Traits","text":"<p>Traits are functions that are executed when entities meet the requirements defined by the Query. They allow you to add custom logic and respond to changes in component states. Here\u2019s an example of a trait that regenerates an entity\u2019s health:</p> <pre><code>local Trait = Celesta.Trait(Query, function(world, entity, scope, health, regeneration)\n\n    local regenerating = task.spawn(function()\n\n        local endTime = os.clock() + regeneration.duration:Get()\n\n        while os.clock() &lt; endTime do\n            task.wait(1)\n\n            local current = health.current:Get()\n            local max = health.max:Get()\n\n            --// Add logic for health regeneration here \n        end\n    end)\n\n    --// Will be canceled when the trait is removed\n    table.insert(scope, regenerating)\nend)\n</code></pre>"},{"location":"Core%20Concepts/Components/","title":"Components","text":"<p>In Celesta, components are essential data structures associated with entities. They store the various attributes and states that define an entity's behavior and characteristics.</p>"},{"location":"Core%20Concepts/Components/#what-are-components","title":"What are Components?","text":"<p>Components are simple data containers attached to entities. They hold specific pieces of information related to an entity, such as position, health, or custom attributes. Components do not contain logic or behavior; instead, they purely represent data.</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Velocity = Celesta.Component {\n    --// Default data for this component\n    current = 16\n}\n</code></pre> <p>Celesta works with reactive data. All data inside components are values, values are data structures with <code>get</code> and <code>set</code> methods.</p> <p>Values allow other structures to work with the changes made to them, enabling dynamic updates and ensuring that any modifications are automatically propagated throughout the system.</p> <p>Due to limitations in Luau, the type-checking is not done automatically, so you must type-cast values in the data fields.</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\ntype Value&lt;D&gt; = Celesta.Value&lt;D&gt;\n\nlocal Velocity = Celesta.Component {\n    current = 16 :: Value&lt;number&gt;\n}\n</code></pre> <p>Luau type-checking</p> <p>Unfortunately, this approach may lead to type-cast errors. As a workaround, you might need to use <code>--!nocheck</code> at the beginning of the code to bypass these type-checking issues.</p> <p>Components don't necessarily need a default data; you can later add more fields or simply not use any.</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Player = Celesta.Component()\n</code></pre> <p>Components that don't have any data are called tags. Tags can be anything; a marker that this entity is a player or even that this entity is a door.</p>"},{"location":"Core%20Concepts/Components/#integrating-components-in-systems","title":"Integrating components in systems","text":"<p>Components encapsulate specific functionality, making it easy to manage and update parts of the system independently.</p> <p>They enable efficient data handling and reactive programming, where systems can automatically respond to changes.</p> <pre><code>local function exampleTrait(entity, world, scope, velocity)\n    local current = velocity.current\n\n    velocity:Computed(function(use)\n        print(use(current))\n    end)\n\nend\n</code></pre> <p>This example demonstrate how a system can wait for a change and executing a function.</p> <p>Making it look easy</p> <p>This example introduces a several new concepts. It's recommended that you explore the documentation further to learn all about them.</p>"},{"location":"Core%20Concepts/Queries/","title":"Queries","text":"<p>Queries are the backbone of efficient entity management in libraries like Celesta. They enable you to sift through a vast pool of entities and get exactly those that match specific criteria, making your system both powerful and precise.</p>"},{"location":"Core%20Concepts/Queries/#why-queries-matter","title":"Why Queries Matter","text":"<p>Instead of processing systems in every entity, queries let you target those that matter \u2014 whether they possess certain components, or meet specific conditions.</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Health = Celesta.Component()\n\nlocal Query = Celesta.Query(Health)\n</code></pre> <p>In this example, the query requires entities to have the <code>Health</code> component. We can take this further by adding specific conditions:</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Health = Celesta.Component()\nlocal Immortal = Celesta.Component()\n\nlocal Query = Celesta.Query(Health):No(Immortal)\n</code></pre> <p>This query selects entities with the <code>Health</code> component, but excludes those that also have the <code>Immortal</code> component.</p>"},{"location":"Core%20Concepts/Traits/","title":"Traits","text":"<p>In the context of Celesta and similar frameworks, traits function as specialized systems that encapsulate behavior and logic associated with entities.</p>"},{"location":"Core%20Concepts/Traits/#understanding-traits","title":"Understanding Traits","text":"<p>Unlike traditional systems that run continuously, traits are invoked under specific conditions, making them efficient and targeted in their operation.</p> <p>Traits are designed to act upon entities when certain criteria are met. For example, when an entity acquires a new component or its state changes, the relevant traits are automatically triggered.</p> <p>This approach minimizes unnecessary processing and allows the system to respond dynamically to changes in the game or entities' state.</p>"},{"location":"Core%20Concepts/Traits/#trait-requirements","title":"Trait requirements","text":"<pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Health = Celesta.Component()\nlocal Query = Celesta.Query(Health)\n\nlocal Trait = Celesta.Trait(Query, 0, function()\nend)\n</code></pre> <p>Traits need a query structure to be valid. The query condition defines whether or not the trait will be applied to an entity.</p>"},{"location":"Core%20Concepts/Traits/#priority","title":"Priority","text":"<pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Health = Celesta.Component()\nlocal Query = Celesta.Query(Health)\n\nlocal FirstTrait = Celesta.Trait(Query, 1, function()\n    print('Trait applied first!')\nend)\n\nlocal LastTrait = Celesta.Trait(Query, 0, function()\n    print('Trait applied last!')\nend)\n</code></pre> <p>Shared queries</p> <p>You can use the same query for multiple traits, allowing you to divide your code in different modules or sections.</p> <p>The second parameter is the priority. The number <code>0</code> is the lowest priority, meaning any trait with a priority greater than <code>0</code> will be processed first. This allows you to control the order in which traits are evaluated, ensuring that critical traits are applied before others.</p> <p>Traits priorities increase sequentially: The higher the number, the later the trait will be processed, except for <code>0</code>, which always has the lowest priority and is processed last.</p>"},{"location":"Core%20Concepts/Traits/#function-parameters","title":"Function parameters","text":"<pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Health = Celesta.Component()\nlocal Query = Celesta.Query(Health)\n\nreturn Celesta.Trait(Query, 1, function(entity, world, scope, health)\nend)\n</code></pre> <p>Modularized code</p> <p>By returning traits in modules, you can easily organize your codebase into different files. From now on, we will use this approach.</p> <p>When a trait is applied, the trait processor is called with the following parameters:</p> <ul> <li><code>entity</code>: The entity to which the trait is applied.</li> <li><code>world</code>: The world that the entity belongs to.</li> <li><code>scope</code>: The scope of the trait (we\u2019ll cover this in more detail soon).</li> <li><code>health</code>: The entity data from the trait's required components.</li> </ul> <p>These parameters provide the necessary context and data for the trait to function correctly.</p>"},{"location":"Core%20Concepts/Traits/#evaluating-traits","title":"Evaluating traits","text":"<p>When you perform an action that trigger a trait to be applied inside a trait, the trait will yield until all the traits that were triggered have been applied.</p> <p>This ensures that all traits that are activated by an action are processed completely before any further actions or evaluations occur.</p> <p>Trait flow are not handled automatically</p> <p>If a trait triggers another trait that yields, the current trait will continue executing. This can lead to errors if the triggered trait has not yet completed its operation.</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Baseplate = Celesta.Component()\nlocal Query = Celesta.Query(Baseplate)\n\nreturn Celesta.Trait(Query, 0, function(entity, world, scope, baseplate)\n    --// Imagine that the trait that creates the part yields.\n    entity:Add(Part)\n\n    local part = entity:Get(Part)\n    local instance = part.instance:Get() --// instance could be nil because the part is not created yet.\n\n    doSomethingWithPart(instance) --&gt; ERROR\nend)\n</code></pre> <p>In this example, if the trait that adds a part yields, the current trait may continue executing before the part is fully created. This can result in errors, such as attempting to operate on a part that has not been fully initialized yet.</p> <p>To prevent this, you should reverse the order of things.</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Part = Celesta.Component()\nlocal Query = Celesta.Query(Part)\n\nreturn Celesta.Trait(Query, 0, function(entity, world, scope, part)\n    local instance = Instance.New('Part')\n\n    part.instance:Set(instance)\n    entity:Add(Baseplate)\nend)\n</code></pre> <p>Create the part first, and then add the baseplate component.</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Baseplate = Celesta.Component()\nlocal Query = Celesta.Query(Part, Baseplate)\n\nreturn Celesta.Trait(Query, 0, function(entity, world, scope, part)\n    --// The part is already created before this trait was applied\n    local instance = part.instance:Get()\n\n    doSomethingWithPart(instance)\nend)\n</code></pre>"},{"location":"Core%20Concepts/Traits/#trait-scope","title":"Trait scope","text":"<p>Traits can be added to or removed from entities, but reverting changes is not done automatically. When removing a trait, you must manually handle the cleanup of any data associated with it.</p> <p>Using the previous example:</p> <pre><code>local Celesta = require(game.ReplicatedStorage.Celesta)\n\nlocal Part = Celesta.Component()\nlocal Query = Celesta.Query(Part)\n\nreturn Celesta.Trait(Query, 0, function(entity, world, scope, part)\n\n    local instance = Instance.New('Part')\n\n    --// The trait scope is cleaned when removed.\n    --// Adding anything to it will be destroyed after its use.\n    table.insert(scope, instance)\n\n    part.instance:Set(instance)\nend)\n</code></pre> <p>In this example, any components or data added to the trait\u2019s scope, such as the instance, will be cleaned up when the trait is removed.</p>"},{"location":"Learning/","title":"Get Started","text":""},{"location":"Learning/#intro","title":"Intro","text":"<p>Welcome to the Celesta guide! Here, we introduces an efficient solution for event-driven programming within Roblox.  </p> <p>This guide explores how Celesta optimizes entity management and component interaction. It is suitable for both newcomers and experienced developers looking to enhance their systems, providing insights and practical examples to fully leverage Celesta and elevate game projects.</p> <p>Still in development</p> <p>Celesta is currently very suitable for breaking changes. Its not recommended to use it for production.</p>"},{"location":"Learning/Contributing/","title":"Contributing","text":"<p>Thank you for your interest in contributing to Celesta! We want to evolve and achieve the best of Celesta, your participation in this is very important.</p>"},{"location":"Learning/Downloading/","title":"Downloading","text":"<p>In development.</p>"}]}